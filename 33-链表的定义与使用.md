# 链表的定义与使用

链表本质是动态对象数组，可实现若干个对象的存储。



## 链表实现简介

在实际开发中，对象数组是一项非常实用的技术，利用其可以描述“多”的概念。

数组的最大缺点在于长度固定，所以实际开发中，传统的数组应用非常有限（数组接收及循环处理）。传统对象数组的开发依赖于脚标（索引）的控制，若要实现动态维护，难度较大。

链表的本质是利用逻辑关系实现类似于数组的数据处理操作，以保存多方数据的形式实现数组的类似功能。链表处理需要公共的结构，该结构可实现数据的保存以及下一个连接的指向。此时需要设计节点类。

![链表结构](https://github.com/JCancy/JAVA/blob/master/picture/%E9%93%BE%E8%A1%A8%E7%BB%93%E6%9E%84.PNG)



## 数据增加 public void add(E e)

在进行链表操作时为避免数据转型异常，应使用泛型，也应设计链表执行标准，具体实现接口应通过Node类做出节点的关系描述。

```java
interface ILink<E> { //设置泛型避免安全隐患
	public void add(E e) ;
}
class LinkImpl<E> implements ILink<E> {
	private class Node { //保存节点数据关系
		private E data ; //保存数据
		private Node next ; //保存下一个引用
		public Node(E data) { //有数据的情况下才有意义
			this.data = data ;
		}
		//第一次调用：this = LinkImpl.root
		//第二次调用：this = LinkImpl.root.next
		//第一次调用：this = LinkImpl.root.next.next
		public void addNode(Node newNode) { //保存新的node数据
			if (this.next == null) { //当前节点的下一个节点
				this.next = newNode ; //保存当前节点
			} else {
				this.next.addNode(newNode) ;
			}
		}
	}
	//---------以下为Link类中定义的成员---------
	private Node root ; //保存根元素
	////-------以下为Link类中定义的方法---------
	public void add(E e) {
		if (e == null) { //保存的数据为null
			return ; //方法调用直接结束
		}
		//数据本身不具有关联特性，需将数据包装在Node类中
		Node newNode = new Node(e) ; //创建新节点
		if (this.root == null) { //若没有根节点
			this.root = newNode ; //第一个节点作为根节点
		} else { //若根节点存在
			this.root.addNode(newNode) ; //将新节点保存在合适位置
		}
	}
}
public class LinkDemo {
	public static void main(String args[]) {
		ILink<String> all = new LinkImpl<String>() ;
		all.add("Hello") ;
		all.add("World") ;
		all.add("GITHUB") ;
	}
}
```

Node 类中并未出现 setter 和 getter 方法，是因为内部类中私有属性也方便外部类使用。

Link 类只负责数据操作与根节点处理，所有后续节点全部由Node类负责完成。




## 获取集合个数 public int size()

链表中保存有大量数据，往往需要进行数据个数统计操作，应在 LinkImpl 子类中追加数据统计信息，当增加或删除数据时，应该对个数进行修改。

1. 在 ILink 接口中追加获取数据个数的方法：
```java
public int size() ; //获取数据个数
```

2. 在 LinkImpl 子类追加个数统计的属性
```java
private int count ; // 2 保存数据个数
```

3. 在 add() 方法中进行数据个数追加
```java
public void add(E e) {
	if (e == null) { //保存的数据为null
		return ; //方法调用直接结束
	}
	//数据本身不具有关联特性，需将数据包装在Node类中
	Node newNode = new Node(e) ; //创建新节点
	if (this.root == null) { //若没有根节点
		this.root = newNode ; //第一个节点作为根节点
	} else { //若根节点存在
		this.root.addNode(newNode) ; //将新节点保存在合适位置
	}
	this.count ++ ; // 3 增加个数
}
```

4. 在 LinkImpl 子类中返回数据个数
```java
public int size() { // 4 返回数据个数
	return this.count ;
}
```

完整代码：
```java
interface ILink<E> { //设置泛型避免安全隐患
	public void add(E e) ;
	public int size() ; // 1 获取数据个数
}
class LinkImpl<E> implements ILink<E> {
	private class Node { //保存节点数据关系
		private E data ; //保存数据
		private Node next ; //保存下一个引用
		public Node(E data) { //有数据的情况下才有意义
			this.data = data ;
		}
		//第一次调用：this = LinkImpl.root
		//第二次调用：this = LinkImpl.root.next
		//第一次调用：this = LinkImpl.root.next.next
		public void addNode(Node newNode) { //保存新的node数据
			if (this.next == null) { //当前节点的下一个节点
				this.next = newNode ; //保存当前节点
			} else {
				this.next.addNode(newNode) ;
			}
		}
	}
	//---------以下为Link类中定义的成员---------
	private Node root ; //保存根元素
	private int count ; // 2 保存数据个数
	////-------以下为Link类中定义的方法---------
	public void add(E e) {
		if (e == null) { //保存的数据为null
			return ; //方法调用直接结束
		}
		//数据本身不具有关联特性，需将数据包装在Node类中
		Node newNode = new Node(e) ; //创建新节点
		if (this.root == null) { //若没有根节点
			this.root = newNode ; //第一个节点作为根节点
		} else { //若根节点存在
			this.root.addNode(newNode) ; //将新节点保存在合适位置
		}
		this.count ++ ; // 3 增加个数
	}
	public int size() { // 4 返回数据个数
		return this.count ;
	}
}
public class LinkDemo {
	public static void main(String args[]) {
		ILink<String> all = new LinkImpl<String>() ;
		System.out.println("【增加之前】数据个数：" + all.size()) ;
		all.add("Hello") ;
		all.add("World") ;
		all.add("GITHUB") ;
		System.out.println("【增加之后】数据个数：" + all.size()) ;
	}
}
```


## 空集合判断 public boolean isEmpty()

链表中可以保存若干数据，若链表还未保存数据，则表示是空集合，应该提供有空判断。

1. 在 ILink 接口中追加判断方法：
```java
public boolean isEmpty() ; //判断是否空集合
```

2. 在 LinkImpl 子类中覆写此方法：
```java
public boolean isEmpty() {  //覆写
	// return this.root == null ;
	return this.count == 0 ; //两种方法本质相同
}
```

完整代码：
```java
interface ILink<E> { //设置泛型避免安全隐患
	public void add(E e) ;
	public int size() ; // 1 获取数据个数
	public boolean isEmpty() ; // 1 判断是否空集合
}
class LinkImpl<E> implements ILink<E> {
	private class Node { //保存节点数据关系
		private E data ; //保存数据
		private Node next ; //保存下一个引用
		public Node(E data) { //有数据的情况下才有意义
			this.data = data ;
		}
		//第一次调用：this = LinkImpl.root
		//第二次调用：this = LinkImpl.root.next
		//第一次调用：this = LinkImpl.root.next.next
		public void addNode(Node newNode) { //保存新的node数据
			if (this.next == null) { //当前节点的下一个节点
				this.next = newNode ; //保存当前节点
			} else {
				this.next.addNode(newNode) ;
			}
		}
	}
	//---------以下为Link类中定义的成员---------
	private Node root ; //保存根元素
	private int count ; // 2 保存数据个数
	////-------以下为Link类中定义的方法---------
	public void add(E e) {
		if (e == null) { //保存的数据为null
			return ; //方法调用直接结束
		}
		//数据本身不具有关联特性，需将数据包装在Node类中
		Node newNode = new Node(e) ; //创建新节点
		if (this.root == null) { //若没有根节点
			this.root = newNode ; //第一个节点作为根节点
		} else { //若根节点存在
			this.root.addNode(newNode) ; //将新节点保存在合适位置
		}
		this.count ++ ; // 3 增加个数
	}
	public int size() { // 4 返回数据个数
		return this.count ;
	}
	public boolean isEmpty() {  //2 覆写
		// return this.root == null ;
		return this.count == 0 ; //两种方法本质相同
	}
}
public class LinkDemo {
	public static void main(String args[]) {
		ILink<String> all = new LinkImpl<String>() ;
		System.out.println("【增加之前】数据个数：" + all.size() + "、是否为空集合：" + all.isEmpty()) ;
		all.add("Hello") ;
		all.add("World") ;
		all.add("GITHUB") ;
		System.out.println("【增加之后】数据个数：" + all.size() + "、是否为空集合：" + all.isEmpty()) ;
	}
}
```


## 返回集合数据 public Object [] toArray()

链表本身属于动态对象数组，可以把所有数据以数组形式返回。此时可定义 toArray() 方法，但此时方法只能返回 Object 型数组。

![数据返回](https://github.com/JCancy/JAVA/blob/master/picture/%E6%95%B0%E6%8D%AE%E8%BF%94%E5%9B%9E.PNG)

1. 在 ILink 接口中追加新方法
```java
public Object [] toArray() ; // 1 将集合元素以数组形式返回
```

2. 在 LinkImpl 中追加两个属性
```java
private int foot ; // 2 描述操作数组的脚标
private Object [] returnData ; //2 返回数据的保存
```


3. 在 Node 类中进行递归调用
```java
//第一次调用：this = LinkImpl.root
//第二次调用：this = LinkImpl.root.next
//第一次调用：this = LinkImpl.root.next.next
public void toArrayNode() {
	LinkImpl.this.returnData [LinkImpl.this.foot ++] = this.data ;
	if (this.next != null) { //还有下一个数据
		this.next.toArrayNode() ;
	}
}

public Object[] toArray() {
		if (this.isEmpty()) { //空集合
			return null ; //现在没有数据
		}
		this.foot = 0 ; //脚标清零
		this.returnData = new Object [this.count] ; //根据已有长度开辟数组
		this.root.toArrayNode() ; //利用Node类进行递归数据获取
		return this.returnData ;
	}
```

完成代码：
```java
interface ILink<E> { //设置泛型避免安全隐患
	public void add(E e) ;
	public int size() ; // 1 获取数据个数
	public boolean isEmpty() ; // 1 判断是否空集合
	public Object [] toArray() ; // 1 将集合元素以数组形式返回
}
class LinkImpl<E> implements ILink<E> {
	private class Node { //保存节点数据关系
		private E data ; //保存数据
		private Node next ; //保存下一个引用
		public Node(E data) { //有数据的情况下才有意义
			this.data = data ;
		}
		//第一次调用：this = LinkImpl.root
		//第二次调用：this = LinkImpl.root.next
		//第一次调用：this = LinkImpl.root.next.next
		public void addNode(Node newNode) { //保存新的node数据
			if (this.next == null) { //当前节点的下一个节点
				this.next = newNode ; //保存当前节点
			} else {
				this.next.addNode(newNode) ;
			}
		}
		//第一次调用：this = LinkImpl.root
		//第二次调用：this = LinkImpl.root.next
		//第一次调用：this = LinkImpl.root.next.next
		public void toArrayNode() {
			LinkImpl.this.returnData [LinkImpl.this.foot ++] = this.data ;
			if (this.next != null) { //还有下一个数据
				this.next.toArrayNode() ;
			}
		}
	}
	//---------以下为Link类中定义的成员---------
	private Node root ; //保存根元素
	private int count ; // 2 保存数据个数
	private int foot ; // 2 描述操作数组的脚标
	private Object [] returnData ; //2 返回数据的保存
	////-------以下为Link类中定义的方法---------
	public void add(E e) {
		if (e == null) { //保存的数据为null
			return ; //方法调用直接结束
		}
		//数据本身不具有关联特性，需将数据包装在Node类中
		Node newNode = new Node(e) ; //创建新节点
		if (this.root == null) { //若没有根节点
			this.root = newNode ; //第一个节点作为根节点
		} else { //若根节点存在
			this.root.addNode(newNode) ; //将新节点保存在合适位置
		}
		this.count ++ ; // 3 增加个数
	}
	public int size() { // 4 返回数据个数
		return this.count ;
	}
	public boolean isEmpty() {  //2 覆写
		// return this.root == null ;
		return this.count == 0 ; //两种方法本质相同
	}
	public Object[] toArray() {
		if (this.isEmpty()) { //空集合
			return null ; //现在没有数据
		}
		this.foot = 0 ; //脚标清零
		this.returnData = new Object [this.count] ; //根据已有长度开辟数组
		this.root.toArrayNode() ; //利用Node类进行递归数据获取
		return this.returnData ;
	}
}
public class LinkDemo {
	public static void main(String args[]) {
		ILink<String> all = new LinkImpl<String>() ;
		System.out.println("【增加之前】数据个数：" + all.size() + "、是否为空集合：" + all.isEmpty()) ;
		all.add("Hello") ;
		all.add("World") ;
		all.add("GITHUB") ;
		System.out.println("【增加之后】数据个数：" + all.size() + "、是否为空集合：" + all.isEmpty()) ;
		Object result [] = all.toArray() ;
		for (Object obj : result) {
			System.out.println(obj) ;
		}
	}
}
```

集合数据若要返回，需以对象数组的形式返回。


## 根据索引取得数据 public E get(int index)

链表可以像数组一样处理，也可以像数组一样进行索引数据获取，即可利用递归形式完成。

![根据索引取得数据](https://github.com/JCancy/JAVA/blob/master/picture/%E6%A0%B9%E6%8D%AE%E7%B4%A2%E5%BC%95%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE.PNG)

1. 在 ILink 接口中追加新方法
```java
public E get(int index) ; // 根据索引获取数据
```

2. 在 Node 类中获取索引实现
```java
public E getNode(int index) {
	if (LinkImpl.this.foot ++ == index) { //索引相同
		return this.data ; //返回当前数据
	} else { //若不同
		return this.next.getNode(index) ; //继续匹配
	}
}
```

3. 在LinkImpl子类中定义数据获取的实现
```java
public E get(int index) {
	if (index >= this.count) { //索引应在指定范围内
		return null ;
	} //索引数据的获取应由Node类完成
	this.foot = 0 ; //重置索引下标
	return this.root.getNode(index) ;
}
```

增加后程序：
```java
interface ILink<E> { //设置泛型避免安全隐患
	public void add(E e) ;
	public int size() ; // 1 获取数据个数
	public boolean isEmpty() ; // 1 判断是否空集合
	public Object [] toArray() ; // 1 将集合元素以数组形式返回
	public E get(int index) ; // 根据索引获取数据
}
class LinkImpl<E> implements ILink<E> {
	private class Node { //保存节点数据关系
		private E data ; //保存数据
		private Node next ; //保存下一个引用
		public Node(E data) { //有数据的情况下才有意义
			this.data = data ;
		}
		//第一次调用：this = LinkImpl.root
		//第二次调用：this = LinkImpl.root.next
		//第一次调用：this = LinkImpl.root.next.next
		public void addNode(Node newNode) { //保存新的node数据
			if (this.next == null) { //当前节点的下一个节点
				this.next = newNode ; //保存当前节点
			} else {
				this.next.addNode(newNode) ;
			}
		}
		//第一次调用：this = LinkImpl.root
		//第二次调用：this = LinkImpl.root.next
		//第一次调用：this = LinkImpl.root.next.next
		public void toArrayNode() {
			LinkImpl.this.returnData [LinkImpl.this.foot ++] = this.data ;
			if (this.next != null) { //还有下一个数据
				this.next.toArrayNode() ;
			}
		}
		public E getNode(int index) {
			if (LinkImpl.this.foot ++ == index) { //索引相同
				return this.data ; //返回当前数据
			} else { //若不同
				return this.next.getNode(index) ; //继续匹配
			}
		}
	}
	//---------以下为Link类中定义的成员---------
	private Node root ; //保存根元素
	private int count ; // 2 保存数据个数
	private int foot ; // 2 描述操作数组的脚标
	private Object [] returnData ; //2 返回数据的保存
	////-------以下为Link类中定义的方法---------
	public void add(E e) {
		if (e == null) { //保存的数据为null
			return ; //方法调用直接结束
		}
		//数据本身不具有关联特性，需将数据包装在Node类中
		Node newNode = new Node(e) ; //创建新节点
		if (this.root == null) { //若没有根节点
			this.root = newNode ; //第一个节点作为根节点
		} else { //若根节点存在
			this.root.addNode(newNode) ; //将新节点保存在合适位置
		}
		this.count ++ ; // 3 增加个数
	}
	public int size() { // 4 返回数据个数
		return this.count ;
	}
	public boolean isEmpty() {  //2 覆写
		// return this.root == null ;
		return this.count == 0 ; //两种方法本质相同
	}
	public Object[] toArray() {
		if (this.isEmpty()) { //空集合
			return null ; //现在没有数据
		}
		this.foot = 0 ; //脚标清零
		this.returnData = new Object [this.count] ; //根据已有长度开辟数组
		this.root.toArrayNode() ; //利用Node类进行递归数据获取
		return this.returnData ;
	}
	public E get(int index) {
		if (index >= this.count) { //索引应在指定范围内
			return null ;
		} //索引数据的获取应由Node类完成
		this.foot = 0 ; //重置索引下标
		return this.root.getNode(index) ;
	}
}
public class LinkDemo {
	public static void main(String args[]) {
		ILink<String> all = new LinkImpl<String>() ;
		System.out.println("【增加之前】数据个数：" + all.size() + "、是否为空集合：" + all.isEmpty()) ;
		all.add("Hello") ;
		all.add("World") ;
		all.add("GITHUB") ;
		System.out.println("【增加之后】数据个数：" + all.size() + "、是否为空集合：" + all.isEmpty()) ;
		Object result [] = all.toArray() ;
		for (Object obj : result) {
			System.out.println(obj) ;
		}
		System.out.println("-------数据获取--------") ;
		System.out.println(all.get(0)) ;
		System.out.println(all.get(1)) ;
		System.out.println(all.get(4)) ;
	}
}
```

数组获取数据的时间复杂度为 1 ，而链表为 n 。




## 链表（修改指定索引数据） public void set(int index, E data)

1. 在ILink中追加新方法
```java
public void set(int index, E data) ; //修改索引数据
```

2. 在 Node 类中提供数据修改处理支持
```java
public void setNode(int index, E data) {
	if (LinkImpl.this.foot ++ == index) { //索引相同
		this.data = data ; //修改数据
	} else {
		this.next.setNode(index, data) ;
	}
}
```

3. 在LinkImpl子类中进行方法覆写
```java
public void set(int index, E data) {
	if (index >= this.count) { //索引应在指定范围内
		return ; //方法结束
	} //索引数据的获取应由Node类完成
	this.foot = 0 ; //重置索引下标
	this.root.setNode(index,data) ; //修改数据
}
```

增加后程序：
```java
interface ILink<E> { //设置泛型避免安全隐患
	public void add(E e) ;
	public int size() ; // 1 获取数据个数
	public boolean isEmpty() ; // 1 判断是否空集合
	public Object [] toArray() ; // 1 将集合元素以数组形式返回
	public E get(int index) ; // 根据索引获取数据
	public void set(int index, E data) ; //修改索引数据
}
class LinkImpl<E> implements ILink<E> {
	private class Node { //保存节点数据关系
		private E data ; //保存数据
		private Node next ; //保存下一个引用
		public Node(E data) { //有数据的情况下才有意义
			this.data = data ;
		}
		//第一次调用：this = LinkImpl.root
		//第二次调用：this = LinkImpl.root.next
		//第一次调用：this = LinkImpl.root.next.next
		public void addNode(Node newNode) { //保存新的node数据
			if (this.next == null) { //当前节点的下一个节点
				this.next = newNode ; //保存当前节点
			} else {
				this.next.addNode(newNode) ;
			}
		}
		//第一次调用：this = LinkImpl.root
		//第二次调用：this = LinkImpl.root.next
		//第一次调用：this = LinkImpl.root.next.next
		public void toArrayNode() {
			LinkImpl.this.returnData [LinkImpl.this.foot ++] = this.data ;
			if (this.next != null) { //还有下一个数据
				this.next.toArrayNode() ;
			}
		}
		public E getNode(int index) {
			if (LinkImpl.this.foot ++ == index) { //索引相同
				return this.data ; //返回当前数据
			} else { //若不同
				return this.next.getNode(index) ; //继续匹配
			}
		}
		public void setNode(int index, E data) {
			if (LinkImpl.this.foot ++ == index) { //索引相同
				this.data = data ; //修改数据
			} else {
				this.next.setNode(index, data) ;
			}
		}
	}
	//---------以下为Link类中定义的成员---------
	private Node root ; //保存根元素
	private int count ; // 2 保存数据个数
	private int foot ; // 2 描述操作数组的脚标
	private Object [] returnData ; //2 返回数据的保存
	////-------以下为Link类中定义的方法---------
	public void add(E e) {
		if (e == null) { //保存的数据为null
			return ; //方法调用直接结束
		}
		//数据本身不具有关联特性，需将数据包装在Node类中
		Node newNode = new Node(e) ; //创建新节点
		if (this.root == null) { //若没有根节点
			this.root = newNode ; //第一个节点作为根节点
		} else { //若根节点存在
			this.root.addNode(newNode) ; //将新节点保存在合适位置
		}
		this.count ++ ; // 3 增加个数
	}
	public int size() { // 4 返回数据个数
		return this.count ;
	}
	public boolean isEmpty() {  //2 覆写
		// return this.root == null ;
		return this.count == 0 ; //两种方法本质相同
	}
	public Object[] toArray() {
		if (this.isEmpty()) { //空集合
			return null ; //现在没有数据
		}
		this.foot = 0 ; //脚标清零
		this.returnData = new Object [this.count] ; //根据已有长度开辟数组
		this.root.toArrayNode() ; //利用Node类进行递归数据获取
		return this.returnData ;
	}
	public E get(int index) {
		if (index >= this.count) { //索引应在指定范围内
			return null ;
		} //索引数据的获取应由Node类完成
		this.foot = 0 ; //重置索引下标
		return this.root.getNode(index) ;
	}
	public void set(int index, E data) {
		if (index >= this.count) { //索引应在指定范围内
			return ; //方法结束
		} //索引数据的获取应由Node类完成
		this.foot = 0 ; //重置索引下标
		this.root.setNode(index,data) ; //修改数据
	}
}
public class LinkDemo {
	public static void main(String args[]) {
		ILink<String> all = new LinkImpl<String>() ;
		System.out.println("【增加之前】数据个数：" + all.size() + "、是否为空集合：" + all.isEmpty()) ;
		all.add("Hello") ;
		all.add("World") ;
		all.add("GITHUB") ;
		all.set(1,"世界") ;
		System.out.println("【增加之后】数据个数：" + all.size() + "、是否为空集合：" + all.isEmpty()) ;
		Object result [] = all.toArray() ;
		for (Object obj : result) {
			System.out.println(obj) ;
		}
		System.out.println("-------数据获取--------") ;
		System.out.println(all.get(0)) ;
		System.out.println(all.get(1)) ;
		System.out.println(all.get(4)) ;
	}
}
```


## 链表（判断数据是否存在） public boolean contains(E data)

1. 在ILink中追加新方法
```java
public boolean contains(E data) ; //判断数据是否存在
```

2. 在 Node 类中提供数据修改处理支持
```java
public boolean containsNode(E data) {
	if(this.data.equals(data)) { //对象比较
		return true ;
	} else {
		if (this.next == null) { //没有后续节点
			return false ; //找不到
		} else {
			return this.next.containsNode(data) ;
		}
	}
}
```

3. 在LinkImpl子类中进行方法覆写
```java
public boolean contains(E data) {
	if (data == null) {
		return false ; //没有数据
	}
	return this.root.containsNode(data) ; //交给Node判断
}
```

增加后程序：
```java
interface ILink<E> { //设置泛型避免安全隐患
	public void add(E e) ;
	public int size() ; // 1 获取数据个数
	public boolean isEmpty() ; // 1 判断是否空集合
	public Object [] toArray() ; // 1 将集合元素以数组形式返回
	public E get(int index) ; // 根据索引获取数据
	public void set(int index, E data) ; //修改索引数据
	public boolean contains(E data) ; //判断数据是否存在
}
class LinkImpl<E> implements ILink<E> {
	private class Node { //保存节点数据关系
		private E data ; //保存数据
		private Node next ; //保存下一个引用
		public Node(E data) { //有数据的情况下才有意义
			this.data = data ;
		}
		//第一次调用：this = LinkImpl.root
		//第二次调用：this = LinkImpl.root.next
		//第一次调用：this = LinkImpl.root.next.next
		public void addNode(Node newNode) { //保存新的node数据
			if (this.next == null) { //当前节点的下一个节点
				this.next = newNode ; //保存当前节点
			} else {
				this.next.addNode(newNode) ;
			}
		}
		//第一次调用：this = LinkImpl.root
		//第二次调用：this = LinkImpl.root.next
		//第一次调用：this = LinkImpl.root.next.next
		public void toArrayNode() {
			LinkImpl.this.returnData [LinkImpl.this.foot ++] = this.data ;
			if (this.next != null) { //还有下一个数据
				this.next.toArrayNode() ;
			}
		}
		public E getNode(int index) {
			if (LinkImpl.this.foot ++ == index) { //索引相同
				return this.data ; //返回当前数据
			} else { //若不同
				return this.next.getNode(index) ; //继续匹配
			}
		}
		public void setNode(int index, E data) {
			if (LinkImpl.this.foot ++ == index) { //索引相同
				this.data = data ; //修改数据
			} else {
				this.next.setNode(index, data) ;
			}
		}
		public boolean containsNode(E data) {
			if(this.data.equals(data)) { //对象比较
				return true ;
			} else {
				if (this.next == null) { //没有后续节点
					return false ; //找不到
				} else {
					return this.next.containsNode(data) ;
				}
			}
		}
	}
	//---------以下为Link类中定义的成员---------
	private Node root ; //保存根元素
	private int count ; // 2 保存数据个数
	private int foot ; // 2 描述操作数组的脚标
	private Object [] returnData ; //2 返回数据的保存
	////-------以下为Link类中定义的方法---------
	public void add(E e) {
		if (e == null) { //保存的数据为null
			return ; //方法调用直接结束
		}
		//数据本身不具有关联特性，需将数据包装在Node类中
		Node newNode = new Node(e) ; //创建新节点
		if (this.root == null) { //若没有根节点
			this.root = newNode ; //第一个节点作为根节点
		} else { //若根节点存在
			this.root.addNode(newNode) ; //将新节点保存在合适位置
		}
		this.count ++ ; // 3 增加个数
	}
	public int size() { // 4 返回数据个数
		return this.count ;
	}
	public boolean isEmpty() {  //2 覆写
		// return this.root == null ;
		return this.count == 0 ; //两种方法本质相同
	}
	public Object[] toArray() {
		if (this.isEmpty()) { //空集合
			return null ; //现在没有数据
		}
		this.foot = 0 ; //脚标清零
		this.returnData = new Object [this.count] ; //根据已有长度开辟数组
		this.root.toArrayNode() ; //利用Node类进行递归数据获取
		return this.returnData ;
	}
	public E get(int index) {
		if (index >= this.count) { //索引应在指定范围内
			return null ;
		} //索引数据的获取应由Node类完成
		this.foot = 0 ; //重置索引下标
		return this.root.getNode(index) ;
	}
	public void set(int index, E data) {
		if (index >= this.count) { //索引应在指定范围内
			return ; //方法结束
		} //索引数据的获取应由Node类完成
		this.foot = 0 ; //重置索引下标
		this.root.setNode(index,data) ; //修改数据
	}
	public boolean contains(E data) {
		if (data == null) {
			return false ; //没有数据
		}
		return this.root.containsNode(data) ; //交给Node判断
	}
}
public class LinkDemo {
	public static void main(String args[]) {
		ILink<String> all = new LinkImpl<String>() ;
		System.out.println("【增加之前】数据个数：" + all.size() + "、是否为空集合：" + all.isEmpty()) ;
		all.add("Hello") ;
		all.add("World") ;
		all.add("GITHUB") ;
		all.set(1,"世界") ;
		System.out.println("【增加之后】数据个数：" + all.size() + "、是否为空集合：" + all.isEmpty()) ;
		Object result [] = all.toArray() ;
		for (Object obj : result) {
			System.out.println(obj) ;
		}
		System.out.println("-------数据获取--------") ;
		System.out.println(all.get(0)) ;
		System.out.println(all.get(1)) ;
		System.out.println(all.get(4)) ;
		System.out.println("-------数据判断--------") ;
		System.out.println(all.contains​("高")) ;
		System.out.println(all.contains​("Hello")) ;
	}
}
```

由于整个链表没有 null 数据存在，所以整体程序判断直接使用每一个数据节点的 equals() 判断。若存在 null 数据，则将不会为空的数据放在 equals 前面进行判断。


## 链表（数据删除） public void remove(E e) 

集合数据的删除需要考虑两种情况：
* 要删除的是根节点数据（LinkImpl 与根节点有关，判断由根节点完成)；
* 要删除的不是根节点数据（由 Node 类完成）。

![删除根结点](https://github.com/JCancy/JAVA/blob/master/picture/%E5%88%A0%E9%99%A4%E6%A0%B9%E8%8A%82%E7%82%B9.PNG)

![删除非根结点](https://github.com/JCancy/JAVA/blob/master/picture/%E5%88%A0%E9%99%A4%E9%9D%9E%E6%A0%B9%E8%8A%82%E7%82%B9.PNG)

1. 在 ILink 中追加新方法
```java
private void remove(E e) ; //数据删除
```

2. 在 LinkImpl 子类中实现根节点判断
```java
public void remove(E data) {
		if (this.contains(data)) { //判断数据是否存在
			if (this.root.data.equals​(data)) { //根节点为要删除的节点
				this.root = this.root.next ; //指向根的下一个节点
			}
			this.count -- ; //数量减少
		}
	}
```

3. 若根节点不是要删除的节点，进行后续节点判断，在 Node 类中追加删除处理
```java
public void removeNode(Node previous, E data) {
	if (this.data.equals​(data)) {
		previous.next = this.next ; //空出当前节点
	} else {
		if (this.next != null) { //有后续节点
			this.next.removeNode(this,data) ; //向后继续删除
		}
	}
}
```

4. 完善 LinkImpl 中的 remove() 方法
```java
public void remove(E data) {
	if (this.contains(data)) { //判断数据是否存在
		if (this.root.data.equals​(data)) { //根节点为要删除的节点
			this.root = this.root.next ; //指向根的下一个节点
		} else { //交由 Node 类负责删除
			this.root.next.removeNode(this.root, data) ;
		}
		this.count -- ; //数量减少
	}
}
```


增加后程序：
```java
interface ILink<E> { //设置泛型避免安全隐患
	public void add(E e) ;
	public int size() ; // 1 获取数据个数
	public boolean isEmpty() ; // 1 判断是否空集合
	public Object [] toArray() ; // 1 将集合元素以数组形式返回
	public E get(int index) ; // 根据索引获取数据
	public void set(int index, E data) ; //修改索引数据
	public boolean contains(E data) ; //判断数据是否存在
	public void remove(E e) ; //数据删除
}
class LinkImpl<E> implements ILink<E> {
	private class Node { //保存节点数据关系
		private E data ; //保存数据
		private Node next ; //保存下一个引用
		public Node(E data) { //有数据的情况下才有意义
			this.data = data ;
		}
		//第一次调用：this = LinkImpl.root
		//第二次调用：this = LinkImpl.root.next
		//第一次调用：this = LinkImpl.root.next.next
		public void addNode(Node newNode) { //保存新的node数据
			if (this.next == null) { //当前节点的下一个节点
				this.next = newNode ; //保存当前节点
			} else {
				this.next.addNode(newNode) ;
			}
		}
		//第一次调用：this = LinkImpl.root
		//第二次调用：this = LinkImpl.root.next
		//第一次调用：this = LinkImpl.root.next.next
		public void toArrayNode() {
			LinkImpl.this.returnData [LinkImpl.this.foot ++] = this.data ;
			if (this.next != null) { //还有下一个数据
				this.next.toArrayNode() ;
			}
		}
		public E getNode(int index) {
			if (LinkImpl.this.foot ++ == index) { //索引相同
				return this.data ; //返回当前数据
			} else { //若不同
				return this.next.getNode(index) ; //继续匹配
			}
		}
		public void setNode(int index, E data) {
			if (LinkImpl.this.foot ++ == index) { //索引相同
				this.data = data ; //修改数据
			} else {
				this.next.setNode(index, data) ;
			}
		}
		public boolean containsNode(E data) {
			if(this.data.equals(data)) { //对象比较
				return true ;
			} else {
				if (this.next == null) { //没有后续节点
					return false ; //找不到
				} else {
					return this.next.containsNode(data) ;
				}
			}
		}
		public void removeNode(Node previous, E data) {
			if (this.data.equals​(data)) {
				previous.next = this.next ; //空出当前节点
			} else {
				if (this.next != null) { //有后续节点
					this.next.removeNode(this,data) ; //向后继续删除
				}
			}
		}
	}
	//---------以下为Link类中定义的成员---------
	private Node root ; //保存根元素
	private int count ; // 2 保存数据个数
	private int foot ; // 2 描述操作数组的脚标
	private Object [] returnData ; //2 返回数据的保存
	////-------以下为Link类中定义的方法---------
	public void add(E e) {
		if (e == null) { //保存的数据为null
			return ; //方法调用直接结束
		}
		//数据本身不具有关联特性，需将数据包装在Node类中
		Node newNode = new Node(e) ; //创建新节点
		if (this.root == null) { //若没有根节点
			this.root = newNode ; //第一个节点作为根节点
		} else { //若根节点存在
			this.root.addNode(newNode) ; //将新节点保存在合适位置
		}
		this.count ++ ; // 3 增加个数
	}
	public int size() { // 4 返回数据个数
		return this.count ;
	}
	public boolean isEmpty() {  //2 覆写
		// return this.root == null ;
		return this.count == 0 ; //两种方法本质相同
	}
	public Object[] toArray() {
		if (this.isEmpty()) { //空集合
			return null ; //现在没有数据
		}
		this.foot = 0 ; //脚标清零
		this.returnData = new Object [this.count] ; //根据已有长度开辟数组
		this.root.toArrayNode() ; //利用Node类进行递归数据获取
		return this.returnData ;
	}
	public E get(int index) {
		if (index >= this.count) { //索引应在指定范围内
			return null ;
		} //索引数据的获取应由Node类完成
		this.foot = 0 ; //重置索引下标
		return this.root.getNode(index) ;
	}
	public void set(int index, E data) {
		if (index >= this.count) { //索引应在指定范围内
			return ; //方法结束
		} //索引数据的获取应由Node类完成
		this.foot = 0 ; //重置索引下标
		this.root.setNode(index,data) ; //修改数据
	}
	public boolean contains(E data) {
		if (data == null) {
			return false ; //没有数据
		}
		return this.root.containsNode(data) ; //交给Node判断
	}
	public void remove(E data) {
		if (this.contains(data)) { //判断数据是否存在
			if (this.root.data.equals​(data)) { //根节点为要删除的节点
				this.root = this.root.next ; //指向根的下一个节点
			} else { //交由 Node 类负责删除
				this.root.next.removeNode(this.root, data) ;
			}
			this.count -- ; //数量减少
		}
	}
}
public class LinkDemo {
	public static void main(String args[]) {
		ILink<String> all = new LinkImpl<String>() ;
		System.out.println("【增加之前】数据个数：" + all.size() + "、是否为空集合：" + all.isEmpty()) ;
		all.add("Hello") ;
		all.add("World") ;
		all.add("GITHUB") ;
		all.remove("World") ;
		System.out.println("【增加之后】数据个数：" + all.size() + "、是否为空集合：" + all.isEmpty()) ;
		Object result [] = all.toArray() ;
		for (Object obj : result) {
			System.out.println(obj) ;
		}
		System.out.println("-------数据获取--------") ;
		System.out.println(all.get(0)) ;
		System.out.println(all.get(1)) ;
		System.out.println(all.get(4)) ;
		System.out.println("-------数据判断--------") ;
		System.out.println(all.contains​("高")) ;
		System.out.println(all.contains​("Hello")) ;
	}
}
```



## 链表（清空链表） public void clean()

清空链表可以直接根据根节点进行控制，只需将 root 设置为 null 。

1. 在 ILink 接口中追加清空处理方法
```java
public void clean() ; //清空集合
```

2. 在LinkImpl子类中进行方法覆写
```java
public void clean() {
	this.root = null ; //后续节点都没有了
	this.count = 0 ; //个数清零
}
```


增加后程序：
```java
interface ILink<E> { //设置泛型避免安全隐患
	public void add(E e) ;
	public int size() ; // 1 获取数据个数
	public boolean isEmpty() ; // 1 判断是否空集合
	public Object [] toArray() ; // 1 将集合元素以数组形式返回
	public E get(int index) ; // 根据索引获取数据
	public void set(int index, E data) ; //修改索引数据
	public boolean contains(E data) ; //判断数据是否存在
	public void remove(E e) ; //数据删除
	public void clean() ; //清空集合
}
class LinkImpl<E> implements ILink<E> {
	private class Node { //保存节点数据关系
		private E data ; //保存数据
		private Node next ; //保存下一个引用
		public Node(E data) { //有数据的情况下才有意义
			this.data = data ;
		}
		//第一次调用：this = LinkImpl.root
		//第二次调用：this = LinkImpl.root.next
		//第一次调用：this = LinkImpl.root.next.next
		public void addNode(Node newNode) { //保存新的node数据
			if (this.next == null) { //当前节点的下一个节点
				this.next = newNode ; //保存当前节点
			} else {
				this.next.addNode(newNode) ;
			}
		}
		//第一次调用：this = LinkImpl.root
		//第二次调用：this = LinkImpl.root.next
		//第一次调用：this = LinkImpl.root.next.next
		public void toArrayNode() {
			LinkImpl.this.returnData [LinkImpl.this.foot ++] = this.data ;
			if (this.next != null) { //还有下一个数据
				this.next.toArrayNode() ;
			}
		}
		public E getNode(int index) {
			if (LinkImpl.this.foot ++ == index) { //索引相同
				return this.data ; //返回当前数据
			} else { //若不同
				return this.next.getNode(index) ; //继续匹配
			}
		}
		public void setNode(int index, E data) {
			if (LinkImpl.this.foot ++ == index) { //索引相同
				this.data = data ; //修改数据
			} else {
				this.next.setNode(index, data) ;
			}
		}
		public boolean containsNode(E data) {
			if(this.data.equals(data)) { //对象比较
				return true ;
			} else {
				if (this.next == null) { //没有后续节点
					return false ; //找不到
				} else {
					return this.next.containsNode(data) ;
				}
			}
		}
		public void removeNode(Node previous, E data) {
			if (this.data.equals​(data)) {
				previous.next = this.next ; //空出当前节点
			} else {
				if (this.next != null) { //有后续节点
					this.next.removeNode(this,data) ; //向后继续删除
				}
			}
		}
	}
	//---------以下为Link类中定义的成员---------
	private Node root ; //保存根元素
	private int count ; // 2 保存数据个数
	private int foot ; // 2 描述操作数组的脚标
	private Object [] returnData ; //2 返回数据的保存
	////-------以下为Link类中定义的方法---------
	public void add(E e) {
		if (e == null) { //保存的数据为null
			return ; //方法调用直接结束
		}
		//数据本身不具有关联特性，需将数据包装在Node类中
		Node newNode = new Node(e) ; //创建新节点
		if (this.root == null) { //若没有根节点
			this.root = newNode ; //第一个节点作为根节点
		} else { //若根节点存在
			this.root.addNode(newNode) ; //将新节点保存在合适位置
		}
		this.count ++ ; // 3 增加个数
	}
	public int size() { // 4 返回数据个数
		return this.count ;
	}
	public boolean isEmpty() {  //2 覆写
		// return this.root == null ;
		return this.count == 0 ; //两种方法本质相同
	}
	public Object[] toArray() {
		if (this.isEmpty()) { //空集合
			return null ; //现在没有数据
		}
		this.foot = 0 ; //脚标清零
		this.returnData = new Object [this.count] ; //根据已有长度开辟数组
		this.root.toArrayNode() ; //利用Node类进行递归数据获取
		return this.returnData ;
	}
	public E get(int index) {
		if (index >= this.count) { //索引应在指定范围内
			return null ;
		} //索引数据的获取应由Node类完成
		this.foot = 0 ; //重置索引下标
		return this.root.getNode(index) ;
	}
	public void set(int index, E data) {
		if (index >= this.count) { //索引应在指定范围内
			return ; //方法结束
		} //索引数据的获取应由Node类完成
		this.foot = 0 ; //重置索引下标
		this.root.setNode(index,data) ; //修改数据
	}
	public boolean contains(E data) {
		if (data == null) {
			return false ; //没有数据
		}
		return this.root.containsNode(data) ; //交给Node判断
	}
	public void remove(E data) {
		if (this.contains(data)) { //判断数据是否存在
			if (this.root.data.equals​(data)) { //根节点为要删除的节点
				this.root = this.root.next ; //指向根的下一个节点
			} else { //交由 Node 类负责删除
				this.root.next.removeNode(this.root, data) ;
			}
			this.count -- ; //数量减少
		}
	}
	public void clean() {
		this.root = null ; //后续节点都没有了
		this.count = 0 ; //个数清零
	}
}
public class LinkDemo {
	public static void main(String args[]) {
		ILink<String> all = new LinkImpl<String>() ;
		System.out.println("【增加之前】数据个数：" + all.size() + "、是否为空集合：" + all.isEmpty()) ;
		all.add("Hello") ;
		all.add("World") ;
		all.add("GITHUB") ;
		all.remove("World") ;
		all.clean() ;
		System.out.println("【增加之后】数据个数：" + all.size() + "、是否为空集合：" + all.isEmpty()) ;
		Object result [] = all.toArray() ;
		if (result != null) {
			for (Object obj : result) {
				System.out.println(obj) ;
			}
		}
		/*System.out.println("-------数据获取--------") ;
		System.out.println(all.get(0)) ;
		System.out.println(all.get(1)) ;
		System.out.println(all.get(4)) ;
		System.out.println("-------数据判断--------") ;
		System.out.println(all.contains​("高")) ;
		System.out.println(all.contains​("Hello")) ;*/
	}
}
```


## 综合实战：宠物商店

假设有宠物商店，可出售各种宠物，要求可以实现宠物的上架/下架处理，也可根据关键字查询出宠物信息。

![宠物商店设计](https://github.com/JCancy/JAVA/blob/master/picture/%E5%AE%A0%E7%89%A9%E5%95%86%E5%BA%97%E8%AE%BE%E8%AE%A1.PNG)

1. 设计宠物标准
```java
interface Pet { //定义宠物标准
	public String getName() ; //获得名字
	public String getColor() ; //获得颜色
}
```

2. 宠物商店
```java
class PetShop { //宠物商店
	private ILink<Pet> allPets = new LinkImpl<Pet>() ; //保存多个宠物信息
	public void add(Pet pet) { //追加宠物，商品上架
		this.allPets.add(pet) ; //集合中保存对象
	}
	public void delete(Pet pet) {
		this.allPets.remove(pet) ;
	}
	public ILink<Pet> search(String keyword) {
		ILink<Pet> searchResult = new LinkImpl<Pet>() ; //保存查询结果
		Object result [] = this.allPets.toArray() ; //获取全部数据
		if (result != null) {
			for (Object obj : result) {
				Pet pet = (pet) obj ;
				if (pet.getName().contains(keyword) ||
					pet.getColor().contains(keyword)) {
					searchResult.add(pet) ; //保存查询结果
				}
			}
		}
		return searchResult ;
	}
}
```

3. 根据宠物标准定义宠物信息
```java
//定义宠物猫
class Cat implements Pet { //实现宠物标准
	private String name ;
	private String color ;
	public Cat(String name, String color) {
		this.name = name ;
		this.color = color ;
	}
	public String getName() {
		return this.name ;
	}
	public String getColor() {
		return this.color ;
	}
	public boolean equals(Object obj) {
		if (obj == null) {
			return false ;
		}
		if (!(obj instanceof Cat)) {
			return false ;
		}
		if (this == obj) {
			return true ;
		}
		Cat cat = (Cat) obj ;
		return this.name.equals(cat.name) && this.color.equals(cat.color) ;
	}
	public String toString() {
		return "【宠物猫】名字：" + this.name + "、颜色：" + this.color ;
	}
}
//定义宠物狗
class Dog implements Pet { //实现宠物标准
	private String name ;
	private String color ;
	public Dog(String name, String color) {
		this.name = name ;
		this.color = color ;
	}
	public String getName() {
		return this.name ;
	}
	public String getColor() {
		return this.color ;
	}
	public boolean equals(Object obj) {
		if (obj == null) {
			return false ;
		}
		if (!(obj instanceof Dog)) {
			return false ;
		}
		if (this == obj) {
			return true ;
		}
		Dog dog = (Dog) obj ;
		return this.name.equals(dog.name) && this.color.equals(dog.color) ;
	}
	public String toString() {
		return "【宠物狗】名字：" + this.name + "、颜色：" + this.color ;
	}
}
```

4. 实现宠物商店的操作
```java
PetShop shop = new PetShop() ; //开店
shop.add(new Dog("大黄狗","黄色")) ;
shop.add(new Dog("二黄狗","红色")) ;
shop.add(new Dog("三黄狗","绿色")) ;
shop.add(new Cat("小白猫","白色")) ;
shop.add(new Cat("小蓝猫","蓝色")) ;
shop.add(new Cat("小黄猫","黄色")) ;
Object result [] = shop.search("黄").toArray() ;
for (Object obj : result) {
	System.out.println(obj) ;
}
``


最终结果：
```java
interface ILink<E> { //设置泛型避免安全隐患
	public void add(E e) ;
	public int size() ; // 1 获取数据个数
	public boolean isEmpty() ; // 1 判断是否空集合
	public Object [] toArray() ; // 1 将集合元素以数组形式返回
	public E get(int index) ; // 根据索引获取数据
	public void set(int index, E data) ; //修改索引数据
	public boolean contains(E data) ; //判断数据是否存在
	public void remove(E e) ; //数据删除
	public void clean() ; //清空集合
}
class LinkImpl<E> implements ILink<E> {
	private class Node { //保存节点数据关系
		private E data ; //保存数据
		private Node next ; //保存下一个引用
		public Node(E data) { //有数据的情况下才有意义
			this.data = data ;
		}
		//第一次调用：this = LinkImpl.root
		//第二次调用：this = LinkImpl.root.next
		//第一次调用：this = LinkImpl.root.next.next
		public void addNode(Node newNode) { //保存新的node数据
			if (this.next == null) { //当前节点的下一个节点
				this.next = newNode ; //保存当前节点
			} else {
				this.next.addNode(newNode) ;
			}
		}
		//第一次调用：this = LinkImpl.root
		//第二次调用：this = LinkImpl.root.next
		//第一次调用：this = LinkImpl.root.next.next
		public void toArrayNode() {
			LinkImpl.this.returnData [LinkImpl.this.foot ++] = this.data ;
			if (this.next != null) { //还有下一个数据
				this.next.toArrayNode() ;
			}
		}
		public E getNode(int index) {
			if (LinkImpl.this.foot ++ == index) { //索引相同
				return this.data ; //返回当前数据
			} else { //若不同
				return this.next.getNode(index) ; //继续匹配
			}
		}
		public void setNode(int index, E data) {
			if (LinkImpl.this.foot ++ == index) { //索引相同
				this.data = data ; //修改数据
			} else {
				this.next.setNode(index, data) ;
			}
		}
		public boolean containsNode(E data) {
			if(this.data.equals(data)) { //对象比较
				return true ;
			} else {
				if (this.next == null) { //没有后续节点
					return false ; //找不到
				} else {
					return this.next.containsNode(data) ;
				}
			}
		}
		public void removeNode(Node previous, E data) {
			if (this.data.equals​(data)) {
				previous.next = this.next ; //空出当前节点
			} else {
				if (this.next != null) { //有后续节点
					this.next.removeNode(this,data) ; //向后继续删除
				}
			}
		}
	}
	//---------以下为Link类中定义的成员---------
	private Node root ; //保存根元素
	private int count ; // 2 保存数据个数
	private int foot ; // 2 描述操作数组的脚标
	private Object [] returnData ; //2 返回数据的保存
	////-------以下为Link类中定义的方法---------
	public void add(E e) {
		if (e == null) { //保存的数据为null
			return ; //方法调用直接结束
		}
		//数据本身不具有关联特性，需将数据包装在Node类中
		Node newNode = new Node(e) ; //创建新节点
		if (this.root == null) { //若没有根节点
			this.root = newNode ; //第一个节点作为根节点
		} else { //若根节点存在
			this.root.addNode(newNode) ; //将新节点保存在合适位置
		}
		this.count ++ ; // 3 增加个数
	}
	public int size() { // 4 返回数据个数
		return this.count ;
	}
	public boolean isEmpty() {  //2 覆写
		// return this.root == null ;
		return this.count == 0 ; //两种方法本质相同
	}
	public Object[] toArray() {
		if (this.isEmpty()) { //空集合
			return null ; //现在没有数据
		}
		this.foot = 0 ; //脚标清零
		this.returnData = new Object [this.count] ; //根据已有长度开辟数组
		this.root.toArrayNode() ; //利用Node类进行递归数据获取
		return this.returnData ;
	}
	public E get(int index) {
		if (index >= this.count) { //索引应在指定范围内
			return null ;
		} //索引数据的获取应由Node类完成
		this.foot = 0 ; //重置索引下标
		return this.root.getNode(index) ;
	}
	public void set(int index, E data) {
		if (index >= this.count) { //索引应在指定范围内
			return ; //方法结束
		} //索引数据的获取应由Node类完成
		this.foot = 0 ; //重置索引下标
		this.root.setNode(index,data) ; //修改数据
	}
	public boolean contains(E data) {
		if (data == null) {
			return false ; //没有数据
		}
		return this.root.containsNode(data) ; //交给Node判断
	}
	public void remove(E data) {
		if (this.contains(data)) { //判断数据是否存在
			if (this.root.data.equals​(data)) { //根节点为要删除的节点
				this.root = this.root.next ; //指向根的下一个节点
			} else { //交由 Node 类负责删除
				this.root.next.removeNode(this.root, data) ;
			}
			this.count -- ; //数量减少
		}
	}
	public void clean() {
		this.root = null ; //后续节点都没有了
		this.count = 0 ; //个数清零
	}
}
interface Pet { //定义宠物标准
	public String getName() ; //获得名字
	public String getColor() ; //获得颜色
}
class PetShop { //宠物商店
	private ILink<Pet> allPets = new LinkImpl<Pet>() ; //保存多个宠物信息
	public void add(Pet pet) { //追加宠物，商品上架
		this.allPets.add(pet) ; //集合中保存对象
	}
	public void delete(Pet pet) {
		this.allPets.remove(pet) ;
	}
	public ILink<Pet> search(String keyword) {
		ILink<Pet> searchResult = new LinkImpl<Pet>() ; //保存查询结果
		Object result [] = this.allPets.toArray() ; //获取全部数据
		if (result != null) {
			for (Object obj : result) {
				Pet pet = (pet) obj ;
				if (pet.getName().contains(keyword) ||
					pet.getColor().contains(keyword)) {
					searchResult.add(pet) ; //保存查询结果
				}
			}
		}
		return searchResult ;
	}
}
class Cat implements Pet { //实现宠物标准
	private String name ;
	private String color ;
	public Cat(String name, String color) {
		this.name = name ;
		this.color = color ;
	}
	public String getName() {
		return this.name ;
	}
	public String getColor() {
		return this.color ;
	}
	public boolean equals(Object obj) {
		if (obj == null) {
			return false ;
		}
		if (!(obj instanceof Cat)) {
			return false ;
		}
		if (this == obj) {
			return true ;
		}
		Cat cat = (Cat) obj ;
		return this.name.equals(cat.name) && this.color.equals(cat.color) ;
	}
	public String toString() {
		return "【宠物猫】名字：" + this.name + "、颜色：" + this.color ;
	}
}
class Dog implements Pet { //实现宠物标准
	private String name ;
	private String color ;
	public Dog(String name, String color) {
		this.name = name ;
		this.color = color ;
	}
	public String getName() {
		return this.name ;
	}
	public String getColor() {
		return this.color ;
	}
	public boolean equals(Object obj) {
		if (obj == null) {
			return false ;
		}
		if (!(obj instanceof Dog)) {
			return false ;
		}
		if (this == obj) {
			return true ;
		}
		Dog dog = (Dog) obj ;
		return this.name.equals(dog.name) && this.color.equals(dog.color) ;
	}
	public String toString() {
		return "【宠物狗】名字：" + this.name + "、颜色：" + this.color ;
	}
}
public class JavaDemo {
	public static void main(String args[]) {
		PetShop shop = new PetShop() ; //开店
		shop.add(new Dog("大黄狗","黄色")) ;
		shop.add(new Dog("二黄狗","红色")) ;
		shop.add(new Dog("三黄狗","绿色")) ;
		shop.add(new Cat("小白猫","白色")) ;
		shop.add(new Cat("小蓝猫","蓝色")) ;
		shop.add(new Cat("小黄猫","黄色")) ;
		Object result [] = shop.search("黄").toArray() ;
		for (Object obj : result) {
			System.out.println(obj) ;
		}
	}
}
```



## 综合实战：超市购物车

去超市买东西，所有买到的东西放进购物车中，最后一起结账。

![购物车](https://github.com/JCancy/JAVA/blob/master/picture/%E8%B4%AD%E7%89%A9%E8%BD%A6.PNG)

1. 定义商品标准
```java
interface IGoods { //定义商品标准
	public String getName() ;
	public double getPrice() ;
}
```


2. 定义购物车处理标准
```java
interface IShopCar {
	public void add(IGoods goods) ; //添加商品信息
	public void delete(IGoods goods) ; //删除商品
	public Object[] getAll() ; //获得购物车中全部商品信息
}
```

3. 定义购物车实现类
```java
class ShopCarImpl implements IShopCar { //购物车
	private ILink<IGoods> allGoodses = new LinkImpl<IGoods>() ;
	public void add(IGoods goods) {
		this.allGoodses.add(goods) ;
	}
	public void delete(IGoods goods) {
		this.allGoodses.remove(goods) ;
	}
	public Object [] getAll() {
		return this.allGoodses.toArray() ;
	}
}
```

4. 定义收银台
```java
class Cashier { //收银台
	private IShopCar shopcar ;
	public Cashier(IShopCar shopcar) {
		this.shopcar = shopcar ;
	}
	public double allPrice() { //计算总价
		double all = 0.0 ;
		Object result [] = this.shopcar.getAll() ;
		for (Object obj : result) {
			IGoods goods = (IGoods) obj ;
			all += goods.getPrice() ;
		}
	}
	public int allCount() { //商品数量
		return this.shopcar.getAll().length ;
	}
}
```

5. 定义商品信息
```java
//图书
class Book implements IGoods {
	private String name ;
	private double price ;
	public Book(String name, double price) {
		this.name = name ;
		this.price = price ;
	}
	public String getName() {
		return this.name ;
	}
	public double getPrice() {
		return this.price ;
	}
	public boolean equals(Object obj) {
		if (obj == null) {
			return false ;
		}
		if (this == obj) {
			return true ;
		}
		if (!(obj instanceof Book)) {
			return false ;
		}
		Book book = (Book) obj ;
		return this.name.equals(book.name) && this.price == book.price ;
	}
	public String toString() {
		return "【图书信息】名称：" + this.name + "、价格：" + this.price ; 
	}
}
//书包
lass Bag implements IGoods {
	private String name ;
	private double price ;
	public Bag(String name, double price) {
		this.name = name ;
		this.price = price ;
	}
	public String getName() {
		return this.name ;
	}
	public double getPrice() {
		return this.price ;
	}
	public boolean equals(Object obj) {
		if (obj == null) {
			return false ;
		}
		if (this == obj) {
			return true ;
		}
		if (!(obj instanceof Bag)) {
			return false ;
		}
		Bag bag = (Bag) obj ;
		return this.name.equals(bag.name) && this.price == bag.price ;
	}
	public String toString() {
		return "【书包信息】名称：" + this.name + "、价格：" + this.price ; 
	}
}
```

6. 进行代码测试
```java
public class JavaDemo {
	public static void main(String args[]) {
		IShopCar car = new ShopCarImpl() ;
		car.add(new Book("Java开发",79.8)) ;
		car.add(new Book("Python开发",46.3)) ;
		car.add(new Bag("海绵宝宝书包",557.0)) ;
		Cashier cas = new Cashier(car) ;
		System.out.printlm("总价：" + cas.allPrice() + "、总数：" + cas.allCount()) ;
	}
}
```


最终结果：
```java
interface ILink<E> { //设置泛型避免安全隐患
	public void add(E e) ;
	public int size() ; // 1 获取数据个数
	public boolean isEmpty() ; // 1 判断是否空集合
	public Object [] toArray() ; // 1 将集合元素以数组形式返回
	public E get(int index) ; // 根据索引获取数据
	public void set(int index, E data) ; //修改索引数据
	public boolean contains(E data) ; //判断数据是否存在
	public void remove(E e) ; //数据删除
	public void clean() ; //清空集合
}
class LinkImpl<E> implements ILink<E> {
	private class Node { //保存节点数据关系
		private E data ; //保存数据
		private Node next ; //保存下一个引用
		public Node(E data) { //有数据的情况下才有意义
			this.data = data ;
		}
		//第一次调用：this = LinkImpl.root
		//第二次调用：this = LinkImpl.root.next
		//第一次调用：this = LinkImpl.root.next.next
		public void addNode(Node newNode) { //保存新的node数据
			if (this.next == null) { //当前节点的下一个节点
				this.next = newNode ; //保存当前节点
			} else {
				this.next.addNode(newNode) ;
			}
		}
		//第一次调用：this = LinkImpl.root
		//第二次调用：this = LinkImpl.root.next
		//第一次调用：this = LinkImpl.root.next.next
		public void toArrayNode() {
			LinkImpl.this.returnData [LinkImpl.this.foot ++] = this.data ;
			if (this.next != null) { //还有下一个数据
				this.next.toArrayNode() ;
			}
		}
		public E getNode(int index) {
			if (LinkImpl.this.foot ++ == index) { //索引相同
				return this.data ; //返回当前数据
			} else { //若不同
				return this.next.getNode(index) ; //继续匹配
			}
		}
		public void setNode(int index, E data) {
			if (LinkImpl.this.foot ++ == index) { //索引相同
				this.data = data ; //修改数据
			} else {
				this.next.setNode(index, data) ;
			}
		}
		public boolean containsNode(E data) {
			if(this.data.equals(data)) { //对象比较
				return true ;
			} else {
				if (this.next == null) { //没有后续节点
					return false ; //找不到
				} else {
					return this.next.containsNode(data) ;
				}
			}
		}
		public void removeNode(Node previous, E data) {
			if (this.data.equals​(data)) {
				previous.next = this.next ; //空出当前节点
			} else {
				if (this.next != null) { //有后续节点
					this.next.removeNode(this,data) ; //向后继续删除
				}
			}
		}
	}
	//---------以下为Link类中定义的成员---------
	private Node root ; //保存根元素
	private int count ; // 2 保存数据个数
	private int foot ; // 2 描述操作数组的脚标
	private Object [] returnData ; //2 返回数据的保存
	////-------以下为Link类中定义的方法---------
	public void add(E e) {
		if (e == null) { //保存的数据为null
			return ; //方法调用直接结束
		}
		//数据本身不具有关联特性，需将数据包装在Node类中
		Node newNode = new Node(e) ; //创建新节点
		if (this.root == null) { //若没有根节点
			this.root = newNode ; //第一个节点作为根节点
		} else { //若根节点存在
			this.root.addNode(newNode) ; //将新节点保存在合适位置
		}
		this.count ++ ; // 3 增加个数
	}
	public int size() { // 4 返回数据个数
		return this.count ;
	}
	public boolean isEmpty() {  //2 覆写
		// return this.root == null ;
		return this.count == 0 ; //两种方法本质相同
	}
	public Object[] toArray() {
		if (this.isEmpty()) { //空集合
			return null ; //现在没有数据
		}
		this.foot = 0 ; //脚标清零
		this.returnData = new Object [this.count] ; //根据已有长度开辟数组
		this.root.toArrayNode() ; //利用Node类进行递归数据获取
		return this.returnData ;
	}
	public E get(int index) {
		if (index >= this.count) { //索引应在指定范围内
			return null ;
		} //索引数据的获取应由Node类完成
		this.foot = 0 ; //重置索引下标
		return this.root.getNode(index) ;
	}
	public void set(int index, E data) {
		if (index >= this.count) { //索引应在指定范围内
			return ; //方法结束
		} //索引数据的获取应由Node类完成
		this.foot = 0 ; //重置索引下标
		this.root.setNode(index,data) ; //修改数据
	}
	public boolean contains(E data) {
		if (data == null) {
			return false ; //没有数据
		}
		return this.root.containsNode(data) ; //交给Node判断
	}
	public void remove(E data) {
		if (this.contains(data)) { //判断数据是否存在
			if (this.root.data.equals​(data)) { //根节点为要删除的节点
				this.root = this.root.next ; //指向根的下一个节点
			} else { //交由 Node 类负责删除
				this.root.next.removeNode(this.root, data) ;
			}
			this.count -- ; //数量减少
		}
	}
	public void clean() {
		this.root = null ; //后续节点都没有了
		this.count = 0 ; //个数清零
	}
}
interface IGoods { //定义商品标准
	public String getName() ;
	public double getPrice() ;
}
interface IShopCar {
	public void add(IGoods goods) ; //添加商品信息
	public void delete(IGoods goods) ; //删除商品
	public Object[] getAll() ; //获得购物车中全部商品信息
}
class ShopCarImpl implements IShopCar { //购物车
	private ILink<IGoods> allGoodses = new LinkImpl<IGoods>() ;
	public void add(IGoods goods) {
		this.allGoodses.add(goods) ;
	}
	public void delete(IGoods goods) {
		this.allGoodses.remove(goods) ;
	}
	public Object [] getAll() {
		return this.allGoodses.toArray() ;
	}
}
class Cashier { //收银台
	private IShopCar shopcar ;
	public Cashier(IShopCar shopcar) {
		this.shopcar = shopcar ;
	}
	public double allPrice() { //计算总价
		double all = 0.0 ;
		Object result [] = this.shopcar.getAll() ;
		for (Object obj : result) {
			IGoods goods = (IGoods) obj ;
			all += goods.getPrice() ;
		}
		return all ;
	}
	public int allCount() { //商品数量
		return this.shopcar.getAll().length ;
	}
}
class Book implements IGoods {
	private String name ;
	private double price ;
	public Book(String name, double price) {
		this.name = name ;
		this.price = price ;
	}
	public String getName() {
		return this.name ;
	}
	public double getPrice() {
		return this.price ;
	}
	public boolean equals(Object obj) {
		if (obj == null) {
			return false ;
		}
		if (this == obj) {
			return true ;
		}
		if (!(obj instanceof Book)) {
			return false ;
		}
		Book book = (Book) obj ;
		return this.name.equals(book.name) && this.price == book.price ;
	}
	public String toString() {
		return "【图书信息】名称：" + this.name + "、价格：" + this.price ; 
	}
}
class Bag implements IGoods {
	private String name ;
	private double price ;
	public Bag(String name, double price) {
		this.name = name ;
		this.price = price ;
	}
	public String getName() {
		return this.name ;
	}
	public double getPrice() {
		return this.price ;
	}
	public boolean equals(Object obj) {
		if (obj == null) {
			return false ;
		}
		if (this == obj) {
			return true ;
		}
		if (!(obj instanceof Bag)) {
			return false ;
		}
		Bag bag = (Bag) obj ;
		return this.name.equals(bag.name) && this.price == bag.price ;
	}
	public String toString() {
		return "【书包信息】名称：" + this.name + "、价格：" + this.price ; 
	}
}
public class JavaDemo {
	public static void main(String args[]) {
		IShopCar car = new ShopCarImpl() ;
		car.add(new Book("Java开发",79.8)) ;
		car.add(new Book("Python开发",46.3)) ;
		car.add(new Bag("海绵宝宝书包",557.0)) ;
		Cashier cas = new Cashier(car) ;
		System.out.println("总价：" + cas.allPrice() + "、总数：" + cas.allCount()) ;
	}
}
```

